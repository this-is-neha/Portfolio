{"ast":null,"code":"const threshold = 50;\nconst maxSpeed = 25;\nconst overflowStyles = new Set([\"auto\", \"scroll\"]);\n// Track initial scroll limits per scrollable element (Bug 1 fix)\nconst initialScrollLimits = new WeakMap();\nconst activeScrollEdge = new WeakMap();\n// Track which group element is currently dragging to clear state on end\nlet currentGroupElement = null;\nfunction resetAutoScrollState() {\n  if (currentGroupElement) {\n    const scrollableAncestor = findScrollableAncestor(currentGroupElement, \"y\");\n    if (scrollableAncestor) {\n      activeScrollEdge.delete(scrollableAncestor);\n      initialScrollLimits.delete(scrollableAncestor);\n    }\n    // Also try x axis\n    const scrollableAncestorX = findScrollableAncestor(currentGroupElement, \"x\");\n    if (scrollableAncestorX && scrollableAncestorX !== scrollableAncestor) {\n      activeScrollEdge.delete(scrollableAncestorX);\n      initialScrollLimits.delete(scrollableAncestorX);\n    }\n    currentGroupElement = null;\n  }\n}\nfunction isScrollableElement(element, axis) {\n  const style = getComputedStyle(element);\n  const overflow = axis === \"x\" ? style.overflowX : style.overflowY;\n  return overflowStyles.has(overflow);\n}\nfunction findScrollableAncestor(element, axis) {\n  let current = element?.parentElement;\n  while (current) {\n    if (isScrollableElement(current, axis)) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return null;\n}\nfunction getScrollAmount(pointerPosition, scrollElement, axis) {\n  const rect = scrollElement.getBoundingClientRect();\n  const start = axis === \"x\" ? rect.left : rect.top;\n  const end = axis === \"x\" ? rect.right : rect.bottom;\n  const distanceFromStart = pointerPosition - start;\n  const distanceFromEnd = end - pointerPosition;\n  if (distanceFromStart < threshold) {\n    const intensity = 1 - distanceFromStart / threshold;\n    return {\n      amount: -maxSpeed * intensity * intensity,\n      edge: \"start\"\n    };\n  } else if (distanceFromEnd < threshold) {\n    const intensity = 1 - distanceFromEnd / threshold;\n    return {\n      amount: maxSpeed * intensity * intensity,\n      edge: \"end\"\n    };\n  }\n  return {\n    amount: 0,\n    edge: null\n  };\n}\nfunction autoScrollIfNeeded(groupElement, pointerPosition, axis, velocity) {\n  if (!groupElement) return;\n  // Track the group element for cleanup\n  currentGroupElement = groupElement;\n  const scrollableAncestor = findScrollableAncestor(groupElement, axis);\n  if (!scrollableAncestor) return;\n  // Convert pointer position from page coordinates to viewport coordinates.\n  // The gesture system uses pageX/pageY but getBoundingClientRect() returns\n  // viewport-relative coordinates, so we need to account for page scroll.\n  const viewportPointerPosition = pointerPosition - (axis === \"x\" ? window.scrollX : window.scrollY);\n  const {\n    amount: scrollAmount,\n    edge\n  } = getScrollAmount(viewportPointerPosition, scrollableAncestor, axis);\n  // If not in any threshold zone, clear all state\n  if (edge === null) {\n    activeScrollEdge.delete(scrollableAncestor);\n    initialScrollLimits.delete(scrollableAncestor);\n    return;\n  }\n  const currentActiveEdge = activeScrollEdge.get(scrollableAncestor);\n  // If not currently scrolling this edge, check velocity to see if we should start\n  if (currentActiveEdge !== edge) {\n    // Only start scrolling if velocity is towards the edge\n    const shouldStart = edge === \"start\" && velocity < 0 || edge === \"end\" && velocity > 0;\n    if (!shouldStart) return;\n    // Activate this edge\n    activeScrollEdge.set(scrollableAncestor, edge);\n    // Record initial scroll limit (prevents infinite scroll)\n    const maxScroll = axis === \"x\" ? scrollableAncestor.scrollWidth - scrollableAncestor.clientWidth : scrollableAncestor.scrollHeight - scrollableAncestor.clientHeight;\n    initialScrollLimits.set(scrollableAncestor, maxScroll);\n  }\n  // Cap scrolling at initial limit (prevents infinite scroll)\n  if (scrollAmount > 0) {\n    const initialLimit = initialScrollLimits.get(scrollableAncestor);\n    const currentScroll = axis === \"x\" ? scrollableAncestor.scrollLeft : scrollableAncestor.scrollTop;\n    if (currentScroll >= initialLimit) return;\n  }\n  // Apply scroll\n  if (axis === \"x\") {\n    scrollableAncestor.scrollLeft += scrollAmount;\n  } else {\n    scrollableAncestor.scrollTop += scrollAmount;\n  }\n}\nexport { autoScrollIfNeeded, resetAutoScrollState };","map":{"version":3,"names":["threshold","maxSpeed","overflowStyles","Set","initialScrollLimits","WeakMap","activeScrollEdge","currentGroupElement","resetAutoScrollState","scrollableAncestor","findScrollableAncestor","delete","scrollableAncestorX","isScrollableElement","element","axis","style","getComputedStyle","overflow","overflowX","overflowY","has","current","parentElement","getScrollAmount","pointerPosition","scrollElement","rect","getBoundingClientRect","start","left","top","end","right","bottom","distanceFromStart","distanceFromEnd","intensity","amount","edge","autoScrollIfNeeded","groupElement","velocity","viewportPointerPosition","window","scrollX","scrollY","scrollAmount","currentActiveEdge","get","shouldStart","set","maxScroll","scrollWidth","clientWidth","scrollHeight","clientHeight","initialLimit","currentScroll","scrollLeft","scrollTop"],"sources":["C:\\Users\\Asus\\Desktop\\My projects\\PortFolio\\Frontend\\node_modules\\framer-motion\\src\\components\\Reorder\\utils\\auto-scroll.ts"],"sourcesContent":["const threshold = 50\nconst maxSpeed = 25\n\nconst overflowStyles = new Set([\"auto\", \"scroll\"])\n\n// Track initial scroll limits per scrollable element (Bug 1 fix)\nconst initialScrollLimits = new WeakMap<HTMLElement, number>()\n\n// Track auto-scroll active state per edge: \"start\" (top/left) or \"end\" (bottom/right)\ntype ActiveEdge = \"start\" | \"end\" | null\nconst activeScrollEdge = new WeakMap<HTMLElement, ActiveEdge>()\n\n// Track which group element is currently dragging to clear state on end\nlet currentGroupElement: Element | null = null\n\nexport function resetAutoScrollState(): void {\n    if (currentGroupElement) {\n        const scrollableAncestor = findScrollableAncestor(\n            currentGroupElement,\n            \"y\"\n        )\n        if (scrollableAncestor) {\n            activeScrollEdge.delete(scrollableAncestor)\n            initialScrollLimits.delete(scrollableAncestor)\n        }\n        // Also try x axis\n        const scrollableAncestorX = findScrollableAncestor(\n            currentGroupElement,\n            \"x\"\n        )\n        if (scrollableAncestorX && scrollableAncestorX !== scrollableAncestor) {\n            activeScrollEdge.delete(scrollableAncestorX)\n            initialScrollLimits.delete(scrollableAncestorX)\n        }\n        currentGroupElement = null\n    }\n}\n\nfunction isScrollableElement(element: Element, axis: \"x\" | \"y\"): boolean {\n    const style = getComputedStyle(element)\n    const overflow = axis === \"x\" ? style.overflowX : style.overflowY\n    return overflowStyles.has(overflow)\n}\n\nfunction findScrollableAncestor(\n    element: Element | null,\n    axis: \"x\" | \"y\"\n): HTMLElement | null {\n    let current = element?.parentElement\n    while (current) {\n        if (isScrollableElement(current, axis)) {\n            return current\n        }\n        current = current.parentElement\n    }\n    return null\n}\n\nfunction getScrollAmount(\n    pointerPosition: number,\n    scrollElement: HTMLElement,\n    axis: \"x\" | \"y\"\n): { amount: number; edge: ActiveEdge } {\n    const rect = scrollElement.getBoundingClientRect()\n\n    const start = axis === \"x\" ? rect.left : rect.top\n    const end = axis === \"x\" ? rect.right : rect.bottom\n\n    const distanceFromStart = pointerPosition - start\n    const distanceFromEnd = end - pointerPosition\n\n    if (distanceFromStart < threshold) {\n        const intensity = 1 - distanceFromStart / threshold\n        return { amount: -maxSpeed * intensity * intensity, edge: \"start\" }\n    } else if (distanceFromEnd < threshold) {\n        const intensity = 1 - distanceFromEnd / threshold\n        return { amount: maxSpeed * intensity * intensity, edge: \"end\" }\n    }\n\n    return { amount: 0, edge: null }\n}\n\nexport function autoScrollIfNeeded(\n    groupElement: Element | null,\n    pointerPosition: number,\n    axis: \"x\" | \"y\",\n    velocity: number\n): void {\n    if (!groupElement) return\n\n    // Track the group element for cleanup\n    currentGroupElement = groupElement\n\n    const scrollableAncestor = findScrollableAncestor(groupElement, axis)\n    if (!scrollableAncestor) return\n\n    // Convert pointer position from page coordinates to viewport coordinates.\n    // The gesture system uses pageX/pageY but getBoundingClientRect() returns\n    // viewport-relative coordinates, so we need to account for page scroll.\n    const viewportPointerPosition =\n        pointerPosition - (axis === \"x\" ? window.scrollX : window.scrollY)\n\n    const { amount: scrollAmount, edge } = getScrollAmount(\n        viewportPointerPosition,\n        scrollableAncestor,\n        axis\n    )\n\n    // If not in any threshold zone, clear all state\n    if (edge === null) {\n        activeScrollEdge.delete(scrollableAncestor)\n        initialScrollLimits.delete(scrollableAncestor)\n        return\n    }\n\n    const currentActiveEdge = activeScrollEdge.get(scrollableAncestor)\n\n    // If not currently scrolling this edge, check velocity to see if we should start\n    if (currentActiveEdge !== edge) {\n        // Only start scrolling if velocity is towards the edge\n        const shouldStart =\n            (edge === \"start\" && velocity < 0) ||\n            (edge === \"end\" && velocity > 0)\n        if (!shouldStart) return\n\n        // Activate this edge\n        activeScrollEdge.set(scrollableAncestor, edge)\n\n        // Record initial scroll limit (prevents infinite scroll)\n        const maxScroll =\n            axis === \"x\"\n                ? scrollableAncestor.scrollWidth -\n                  scrollableAncestor.clientWidth\n                : scrollableAncestor.scrollHeight -\n                  scrollableAncestor.clientHeight\n        initialScrollLimits.set(scrollableAncestor, maxScroll)\n    }\n\n    // Cap scrolling at initial limit (prevents infinite scroll)\n    if (scrollAmount > 0) {\n        const initialLimit = initialScrollLimits.get(scrollableAncestor)!\n        const currentScroll =\n            axis === \"x\"\n                ? scrollableAncestor.scrollLeft\n                : scrollableAncestor.scrollTop\n        if (currentScroll >= initialLimit) return\n    }\n\n    // Apply scroll\n    if (axis === \"x\") {\n        scrollableAncestor.scrollLeft += scrollAmount\n    } else {\n        scrollableAncestor.scrollTop += scrollAmount\n    }\n}\n"],"mappings":"AAAA,MAAMA,SAAS,GAAG,EAAE;AACpB,MAAMC,QAAQ,GAAG,EAAE;AAEnB,MAAMC,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;AAElD;AACA,MAAMC,mBAAmB,GAAG,IAAIC,OAAO,EAAuB;AAI9D,MAAMC,gBAAgB,GAAG,IAAID,OAAO,EAA2B;AAE/D;AACA,IAAIE,mBAAmB,GAAmB,IAAI;SAE9BC,oBAAoBA,CAAA;EAChC,IAAID,mBAAmB,EAAE;IACrB,MAAME,kBAAkB,GAAGC,sBAAsB,CAC7CH,mBAAmB,EACnB,GAAG,CACN;IACD,IAAIE,kBAAkB,EAAE;MACpBH,gBAAgB,CAACK,MAAM,CAACF,kBAAkB,CAAC;MAC3CL,mBAAmB,CAACO,MAAM,CAACF,kBAAkB,CAAC;;;IAGlD,MAAMG,mBAAmB,GAAGF,sBAAsB,CAC9CH,mBAAmB,EACnB,GAAG,CACN;IACD,IAAIK,mBAAmB,IAAIA,mBAAmB,KAAKH,kBAAkB,EAAE;MACnEH,gBAAgB,CAACK,MAAM,CAACC,mBAAmB,CAAC;MAC5CR,mBAAmB,CAACO,MAAM,CAACC,mBAAmB,CAAC;;IAEnDL,mBAAmB,GAAG,IAAI;;AAElC;AAEA,SAASM,mBAAmBA,CAACC,OAAgB,EAAEC,IAAe;EAC1D,MAAMC,KAAK,GAAGC,gBAAgB,CAACH,OAAO,CAAC;EACvC,MAAMI,QAAQ,GAAGH,IAAI,KAAK,GAAG,GAAGC,KAAK,CAACG,SAAS,GAAGH,KAAK,CAACI,SAAS;EACjE,OAAOlB,cAAc,CAACmB,GAAG,CAACH,QAAQ,CAAC;AACvC;AAEA,SAASR,sBAAsBA,CAC3BI,OAAuB,EACvBC,IAAe;EAEf,IAAIO,OAAO,GAAGR,OAAO,EAAES,aAAa;EACpC,OAAOD,OAAO,EAAE;IACZ,IAAIT,mBAAmB,CAACS,OAAO,EAAEP,IAAI,CAAC,EAAE;MACpC,OAAOO,OAAO;;IAElBA,OAAO,GAAGA,OAAO,CAACC,aAAa;;EAEnC,OAAO,IAAI;AACf;AAEA,SAASC,eAAeA,CACpBC,eAAuB,EACvBC,aAA0B,EAC1BX,IAAe;EAEf,MAAMY,IAAI,GAAGD,aAAa,CAACE,qBAAqB,EAAE;EAElD,MAAMC,KAAK,GAAGd,IAAI,KAAK,GAAG,GAAGY,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACI,GAAG;EACjD,MAAMC,GAAG,GAAGjB,IAAI,KAAK,GAAG,GAAGY,IAAI,CAACM,KAAK,GAAGN,IAAI,CAACO,MAAM;EAEnD,MAAMC,iBAAiB,GAAGV,eAAe,GAAGI,KAAK;EACjD,MAAMO,eAAe,GAAGJ,GAAG,GAAGP,eAAe;EAE7C,IAAIU,iBAAiB,GAAGnC,SAAS,EAAE;IAC/B,MAAMqC,SAAS,GAAG,CAAC,GAAGF,iBAAiB,GAAGnC,SAAS;IACnD,OAAO;MAAEsC,MAAM,EAAE,CAACrC,QAAQ,GAAGoC,SAAS,GAAGA,SAAS;MAAEE,IAAI,EAAE;IAAO,CAAE;GACtE,MAAM,IAAIH,eAAe,GAAGpC,SAAS,EAAE;IACpC,MAAMqC,SAAS,GAAG,CAAC,GAAGD,eAAe,GAAGpC,SAAS;IACjD,OAAO;MAAEsC,MAAM,EAAErC,QAAQ,GAAGoC,SAAS,GAAGA,SAAS;MAAEE,IAAI,EAAE;IAAK,CAAE;;EAGpE,OAAO;IAAED,MAAM,EAAE,CAAC;IAAEC,IAAI,EAAE;EAAI,CAAE;AACpC;AAEM,SAAUC,kBAAkBA,CAC9BC,YAA4B,EAC5BhB,eAAuB,EACvBV,IAAe,EACf2B,QAAgB;EAEhB,IAAI,CAACD,YAAY,EAAE;;EAGnBlC,mBAAmB,GAAGkC,YAAY;EAElC,MAAMhC,kBAAkB,GAAGC,sBAAsB,CAAC+B,YAAY,EAAE1B,IAAI,CAAC;EACrE,IAAI,CAACN,kBAAkB,EAAE;;;;EAKzB,MAAMkC,uBAAuB,GACzBlB,eAAe,IAAIV,IAAI,KAAK,GAAG,GAAG6B,MAAM,CAACC,OAAO,GAAGD,MAAM,CAACE,OAAO,CAAC;EAEtE,MAAM;IAAER,MAAM,EAAES,YAAY;IAAER;EAAI,CAAE,GAAGf,eAAe,CAClDmB,uBAAuB,EACvBlC,kBAAkB,EAClBM,IAAI,CACP;;EAGD,IAAIwB,IAAI,KAAK,IAAI,EAAE;IACfjC,gBAAgB,CAACK,MAAM,CAACF,kBAAkB,CAAC;IAC3CL,mBAAmB,CAACO,MAAM,CAACF,kBAAkB,CAAC;IAC9C;;EAGJ,MAAMuC,iBAAiB,GAAG1C,gBAAgB,CAAC2C,GAAG,CAACxC,kBAAkB,CAAC;;EAGlE,IAAIuC,iBAAiB,KAAKT,IAAI,EAAE;;IAE5B,MAAMW,WAAW,GACZX,IAAI,KAAK,OAAO,IAAIG,QAAQ,GAAG,CAAC,IAChCH,IAAI,KAAK,KAAK,IAAIG,QAAQ,GAAG,CAAE;IACpC,IAAI,CAACQ,WAAW,EAAE;;IAGlB5C,gBAAgB,CAAC6C,GAAG,CAAC1C,kBAAkB,EAAE8B,IAAI,CAAC;;IAG9C,MAAMa,SAAS,GACXrC,IAAI,KAAK,GAAG,GACNN,kBAAkB,CAAC4C,WAAW,GAC9B5C,kBAAkB,CAAC6C,WAAW,GAC9B7C,kBAAkB,CAAC8C,YAAY,GAC/B9C,kBAAkB,CAAC+C,YAAY;IACzCpD,mBAAmB,CAAC+C,GAAG,CAAC1C,kBAAkB,EAAE2C,SAAS,CAAC;;;EAI1D,IAAIL,YAAY,GAAG,CAAC,EAAE;IAClB,MAAMU,YAAY,GAAGrD,mBAAmB,CAAC6C,GAAG,CAACxC,kBAAkB,CAAE;IACjE,MAAMiD,aAAa,GACf3C,IAAI,KAAK,GAAG,GACNN,kBAAkB,CAACkD,UAAU,GAC7BlD,kBAAkB,CAACmD,SAAS;IACtC,IAAIF,aAAa,IAAID,YAAY,EAAE;;;EAIvC,IAAI1C,IAAI,KAAK,GAAG,EAAE;IACdN,kBAAkB,CAACkD,UAAU,IAAIZ,YAAY;GAChD,MAAM;IACHtC,kBAAkB,CAACmD,SAAS,IAAIb,YAAY;;AAEpD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}