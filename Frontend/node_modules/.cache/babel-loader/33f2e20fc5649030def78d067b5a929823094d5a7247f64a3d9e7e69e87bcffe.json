{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useComposedRefs } from '../../utils/use-composed-ref.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n  getSnapshotBeforeUpdate(prevProps) {\n    const element = this.props.childRef.current;\n    if (element && prevProps.isPresent && !this.props.isPresent) {\n      const parent = element.offsetParent;\n      const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;\n      const parentHeight = isHTMLElement(parent) ? parent.offsetHeight || 0 : 0;\n      const size = this.props.sizeRef.current;\n      size.height = element.offsetHeight || 0;\n      size.width = element.offsetWidth || 0;\n      size.top = element.offsetTop;\n      size.left = element.offsetLeft;\n      size.right = parentWidth - size.width - size.left;\n      size.bottom = parentHeight - size.height - size.top;\n    }\n    return null;\n  }\n  /**\n   * Required with getSnapshotBeforeUpdate to stop React complaining.\n   */\n  componentDidUpdate() {}\n  render() {\n    return this.props.children;\n  }\n}\nfunction PopChild(_ref) {\n  var _children$props$ref, _children$props;\n  let {\n    children,\n    isPresent,\n    anchorX,\n    anchorY,\n    root\n  } = _ref;\n  const id = useId();\n  const ref = useRef(null);\n  const size = useRef({\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  });\n  const {\n    nonce\n  } = useContext(MotionConfigContext);\n  /**\n   * In React 19, refs are passed via props.ref instead of element.ref.\n   * We check props.ref first (React 19) and fall back to element.ref (React 18).\n   */\n  const childRef = (_children$props$ref = (_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.ref) !== null && _children$props$ref !== void 0 ? _children$props$ref : children === null || children === void 0 ? void 0 : children.ref;\n  const composedRef = useComposedRefs(ref, childRef);\n  /**\n   * We create and inject a style block so we can apply this explicit\n   * sizing in a non-destructive manner by just deleting the style block.\n   *\n   * We can't apply size via render as the measurement happens\n   * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n   * styles directly on the DOM node, we might be overwriting\n   * styles set via the style prop.\n   */\n  useInsertionEffect(() => {\n    const {\n      width,\n      height,\n      top,\n      left,\n      right,\n      bottom\n    } = size.current;\n    if (isPresent || !ref.current || !width || !height) return;\n    const x = anchorX === \"left\" ? \"left: \".concat(left) : \"right: \".concat(right);\n    const y = anchorY === \"bottom\" ? \"bottom: \".concat(bottom) : \"top: \".concat(top);\n    ref.current.dataset.motionPopId = id;\n    const style = document.createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    const parent = root !== null && root !== void 0 ? root : document.head;\n    parent.appendChild(style);\n    if (style.sheet) {\n      style.sheet.insertRule(\"\\n          [data-motion-pop-id=\\\"\".concat(id, \"\\\"] {\\n            position: absolute !important;\\n            width: \").concat(width, \"px !important;\\n            height: \").concat(height, \"px !important;\\n            \").concat(x, \"px !important;\\n            \").concat(y, \"px !important;\\n          }\\n        \"));\n    }\n    return () => {\n      if (parent.contains(style)) {\n        parent.removeChild(style);\n      }\n    };\n  }, [isPresent]);\n  return jsx(PopChildMeasure, {\n    isPresent: isPresent,\n    childRef: ref,\n    sizeRef: size,\n    children: React.cloneElement(children, {\n      ref: composedRef\n    })\n  });\n}\nexport { PopChild };","map":{"version":3,"names":["PopChildMeasure","React","Component","getSnapshotBeforeUpdate","prevProps","element","isPresent","props","parent","offsetParent","parentWidth","isHTMLElement","offsetWidth","parentHeight","offsetHeight","size","top","offsetTop","left","offsetLeft","right","width","bottom","height","componentDidUpdate","children","PopChild","_ref","_children$props$ref","_children$props","anchorX","anchorY","root","id","useId","ref","useRef","childRef","current","x","concat","y","nonce","style","document","head","appendChild","sheet","insertRule","contains","removeChild","jsx","sizeRef","cloneElement","composedRef"],"sources":["C:\\Users\\Asus\\Desktop\\My projects\\PortFolio\\Frontend\\node_modules\\framer-motion\\src\\components\\AnimatePresence\\PopChild.tsx"],"sourcesContent":["\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n    bottom: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n            const parentHeight = isHTMLElement(parent)\n                ? parent.offsetHeight || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n            size.bottom = parentHeight - size.height - size.top\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, anchorY, root }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    /**\n     * In React 19, refs are passed via props.ref instead of element.ref.\n     * We check props.ref first (React 19) and fall back to element.ref (React 18).\n     */\n    const childRef =\n        (children.props as { ref?: React.Ref<HTMLElement> })?.ref ??\n        (children as unknown as { ref?: React.Ref<HTMLElement> })?.ref\n    const composedRef = useComposedRefs(ref, childRef)\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right, bottom } = size.current\n        if (isPresent || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n        const y = anchorY === \"bottom\" ? `bottom: ${bottom}` : `top: ${top}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            ${y}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size}>\n            {React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n"],"mappings":";;;;;;;;;AA+BA;;;AAGG;AACH,MAAAA,eAAA,SAAAC,KAAA,CAAAC,SAAA;EACIC,wBAAAC,SAAA;;IAEI,IAAAC,OAAA,IAAAD,SAAA,CAAAE,SAAA,UAAAC,KAAA,CAAAD,SAAA;MACI,MAAAE,MAAA,GAAAH,OAAA,CAAAI,YAAA;MACA,MAAAC,WAAA,GAAAC,aAAA,CAAAH,MAAA,IACIA,MAAA,CAAAI,WAAA,Q;MAEJ,MAAAC,YAAA,GAAAF,aAAA,CAAAH,MAAA,IACIA,MAAA,CAAAM,YAAA,Q;;;;MAMJC,IAAA,CAAAC,GAAA,GAAAX,OAAA,CAAAY,SAAA;MACAF,IAAA,CAAAG,IAAA,GAAAb,OAAA,CAAAc,UAAA;MACAJ,IAAA,CAAAK,KAAA,GAAAV,WAAA,GAAAK,IAAA,CAAAM,KAAA,GAAAN,IAAA,CAAAG,IAAA;MACAH,IAAA,CAAAO,MAAA,GAAAT,YAAA,GAAAE,IAAA,CAAAQ,MAAA,GAAAR,IAAA,CAAAC,GAAA;;IAGJ;;EAGJ;;AAEG;EACHQ,mBAAA;;IAGI,YAAAjB,KAAA,CAAAkB,QAAA;;AAEP;AAEe,SAAAC,SAAAC,IAAA;EAAA,IAAAC,mBAAA,EAAAC,eAAA;EAAA;IAAAJ,QAAA;IAAAnB,SAAA;IAAAwB,OAAA;IAAAC,OAAA;IAAAC;EAAA,IAAAL,IAAA;EACZ,MAAAM,EAAA,GAAAC,KAAA;EACA,MAAAC,GAAA,GAAAC,MAAA;;IAEIf,KAAA;IACAE,MAAA;IACAP,GAAA;IACAE,IAAA;IACAE,KAAA;IACAE,MAAA;EACH;;;;EAED;;;AAGG;EACH,MAAAe,QAAA,IAAAT,mBAAA,IAAAC,eAAA,GAAAJ,QAAA,CAAAlB,KAAA,cAAAsB,eAAA,uBAAAA,eAAA,CAAAM,GAAA,cAAAP,mBAAA,cAAAA,mBAAA,G;;EAKA;;;;;;;;AAQG;;IAEC;MAAAP,KAAA;MAAAE,MAAA;MAAAP,GAAA;MAAAE,IAAA;MAAAE,KAAA;MAAAE;IAAA,IAAAP,IAAA,CAAAuB,OAAA;;IAGA,MAAAC,CAAA,GAAAT,OAAA,uBAAAU,MAAA,CAAAtB,IAAA,cAAAsB,MAAA,CAAApB,KAAA;IACA,MAAAqB,CAAA,GAAAV,OAAA,2BAAAS,MAAA,CAAAlB,MAAA,YAAAkB,MAAA,CAAAxB,GAAA;;;IAKA,IAAA0B,KAAA,EAAWC,KAAA,CAAAD,KAAA,GAAAA,KAAA;IAEX,MAAAlC,MAAA,GAAAwB,IAAA,aAAAA,IAAA,cAAAA,IAAA,GAAAY,QAAA,CAAAC,IAAA;IACArC,MAAA,CAAAsC,WAAA,CAAAH,KAAA;IAEA,IAAAA,KAAA,CAAAI,KAAA;MACIJ,KAAA,CAAAI,KAAA,CAAAC,UAAA,sCAAAR,MAAA,C,+QAQH;;IAGD;MACI,IAAAhC,MAAA,CAAAyC,QAAA,CAAAN,KAAA;QACInC,MAAA,CAAA0C,WAAA,CAAAP,KAAA;;IAER;EACJ,IAAArC,SAAA;EAEA,OAAA6C,GAAA,CAAAnD,eAAA;IAAAM,SAAA,EAAAA,SAAA;IAAA+B,QAAA,EAAAF,GAAA;IAAAiB,OAAA,EAAArC,IAAA;IAAAU,QAAA,EAAAxB,KAAA,CAAAoD,YAAA,CAAA5B,QAAA;MAAAU,GAAA,EAAAmB;IAAA;EAAA;AAKJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}