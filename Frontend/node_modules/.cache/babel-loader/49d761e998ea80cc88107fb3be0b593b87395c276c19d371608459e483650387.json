{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/Asus/Desktop/My projects/PortFolio/Frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/Asus/Desktop/My projects/PortFolio/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"willChange\"];\nimport { warnOnce, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { microtask } from '../frameloop/microtask.mjs';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { motionValue } from '../value/index.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { KeyframeResolver } from '../animation/keyframes/KeyframesResolver.mjs';\nimport { transformProps } from './utils/keys-transform.mjs';\nimport { complex } from '../value/types/complex/index.mjs';\nimport { findValueType } from '../value/types/utils/find.mjs';\nimport { getAnimatableNone } from '../value/types/utils/animatable-none.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { initPrefersReducedMotion } from './utils/reduced-motion/index.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './utils/reduced-motion/state.mjs';\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\nconst propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\n/**\n * Static feature definitions - can be injected by framework layer\n */\nlet featureDefinitions = {};\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\nfunction setFeatureDefinitions(definitions) {\n  featureDefinitions = definitions;\n}\n/**\n * Get the current feature definitions\n */\nfunction getFeatureDefinitions() {\n  return featureDefinitions;\n}\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n    return {};\n  }\n  constructor(_ref) {\n    let {\n      parent,\n      props,\n      presenceContext,\n      reducedMotionConfig,\n      blockInitialAnimation,\n      visualState\n    } = _ref;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    this.shouldReduceMotion = null;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    this.values = new Map();\n    this.KeyframeResolver = KeyframeResolver;\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    this.prevMotionValues = {};\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current) return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.renderScheduledAt = 0.0;\n    this.scheduleRender = () => {\n      const now = time.now();\n      if (this.renderScheduledAt < now) {\n        this.renderScheduledAt = now;\n        frame.render(this.render, false, true);\n      }\n    };\n    const {\n      latestValues,\n      renderState\n    } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = _objectSpread({}, latestValues);\n    this.initialValues = props.initial ? _objectSpread({}, latestValues) : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.blockInitialAnimation = Boolean(blockInitialAnimation);\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't necessarily a breaking change,\n     * more a reflection of the test.\n     */\n    const _this$scrapeMotionVal = this.scrapeMotionValuesFromProps(props, {}, this),\n      {\n        willChange\n      } = _this$scrapeMotionVal,\n      initialMotionValues = _objectWithoutProperties(_this$scrapeMotionVal, _excluded);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key]);\n      }\n    }\n  }\n  mount(instance) {\n    var _this$parent;\n    this.current = instance;\n    visualElementStore.set(instance, this);\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    /**\n     * Determine reduced motion preference. Only initialize the matchMedia\n     * listener if we actually need the dynamic value (i.e., when config\n     * is neither \"never\" nor \"always\").\n     */\n    if (this.reducedMotionConfig === \"never\") {\n      this.shouldReduceMotion = false;\n    } else if (this.reducedMotionConfig === \"always\") {\n      this.shouldReduceMotion = true;\n    } else {\n      if (!hasReducedMotionListener.current) {\n        initPrefersReducedMotion();\n      }\n      this.shouldReduceMotion = prefersReducedMotion.current;\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n    }\n    (_this$parent = this.parent) === null || _this$parent === void 0 || _this$parent.addChild(this);\n    this.update(this.props, this.presenceContext);\n  }\n  unmount() {\n    var _this$parent2;\n    this.projection && this.projection.unmount();\n    cancelFrame(this.notifyUpdate);\n    cancelFrame(this.render);\n    this.valueSubscriptions.forEach(remove => remove());\n    this.valueSubscriptions.clear();\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    (_this$parent2 = this.parent) === null || _this$parent2 === void 0 || _this$parent2.removeChild(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    for (const key in this.features) {\n      const feature = this.features[key];\n      if (feature) {\n        feature.unmount();\n        feature.isMounted = false;\n      }\n    }\n    this.current = null;\n  }\n  addChild(child) {\n    var _this$enteringChildre;\n    this.children.add(child);\n    (_this$enteringChildre = this.enteringChildren) !== null && _this$enteringChildre !== void 0 ? _this$enteringChildre : this.enteringChildren = new Set();\n    this.enteringChildren.add(child);\n  }\n  removeChild(child) {\n    this.children.delete(child);\n    this.enteringChildren && this.enteringChildren.delete(child);\n  }\n  bindToMotionValue(key, value) {\n    if (this.valueSubscriptions.has(key)) {\n      this.valueSubscriptions.get(key)();\n    }\n    const valueIsTransform = transformProps.has(key);\n    if (valueIsTransform && this.onBindTransform) {\n      this.onBindTransform();\n    }\n    const removeOnChange = value.on(\"change\", latestValue => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && frame.preRender(this.notifyUpdate);\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n      this.scheduleRender();\n    });\n    let removeSyncCheck;\n    if (typeof window !== \"undefined\" && window.MotionCheckAppearSync) {\n      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n    }\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      if (removeSyncCheck) removeSyncCheck();\n      if (value.owner) value.stop();\n    });\n  }\n  sortNodePosition(other) {\n    /**\n     * If these nodes aren't even of the same type we can't compare their depth.\n     */\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  updateFeatures() {\n    let key = \"animation\";\n    for (key in featureDefinitions) {\n      const featureDefinition = featureDefinitions[key];\n      if (!featureDefinition) continue;\n      const {\n        isEnabled,\n        Feature: FeatureConstructor\n      } = featureDefinition;\n      /**\n       * If this feature is enabled but not active, make a new instance.\n       */\n      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {\n        this.features[key] = new FeatureConstructor(this);\n      }\n      /**\n       * If we have a feature, mount or update it.\n       */\n      if (this.features[key]) {\n        const feature = this.features[key];\n        if (feature.isMounted) {\n          feature.update();\n        } else {\n          feature.mount();\n          feature.isMounted = true;\n        }\n      }\n    }\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    /**\n     * Update prop event handlers ie onAnimationStart, onAnimationComplete\n     */\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listenerName = \"on\" + key;\n      const listener = props[listenerName];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this), this.prevMotionValues);\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : undefined;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(key, value) {\n    // Remove existing value if it exists\n    const existingValue = this.values.get(key);\n    if (value !== existingValue) {\n      if (existingValue) this.removeValue(key);\n      this.bindToMotionValue(key, value);\n      this.values.set(key, value);\n      this.latestValues[key] = value.get();\n    }\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === undefined && defaultValue !== undefined) {\n      value = motionValue(defaultValue === null ? undefined : defaultValue, {\n        owner: this\n      });\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(key, target) {\n    var _this$getBaseTargetFr;\n    let value = this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : (_this$getBaseTargetFr = this.getBaseTargetFromProps(this.props, key)) !== null && _this$getBaseTargetFr !== void 0 ? _this$getBaseTargetFr : this.readValueFromInstance(this.current, key, this.options);\n    if (value !== undefined && value !== null) {\n      if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(target)) {\n        value = getAnimatableNone(key, target);\n      }\n      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n    }\n    return isMotionValue(value) ? value.get() : value;\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(key) {\n    const {\n      initial\n    } = this.props;\n    let valueFromInitial;\n    if (typeof initial === \"string\" || typeof initial === \"object\") {\n      var _this$presenceContext;\n      const variant = resolveVariantFromProps(this.props, initial, (_this$presenceContext = this.presenceContext) === null || _this$presenceContext === void 0 ? void 0 : _this$presenceContext.custom);\n      if (variant) {\n        valueFromInitial = variant[key];\n      }\n    }\n    /**\n     * If this value still exists in the current initial variant, read that.\n     */\n    if (initial && valueFromInitial !== undefined) {\n      return valueFromInitial;\n    }\n    /**\n     * Alternatively, if this VisualElement config has defined a getBaseTarget\n     * so we can read the value from an alternative source, try that.\n     */\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== undefined && !isMotionValue(target)) return target;\n    /**\n     * If the value was initially defined on initial, but it doesn't any more,\n     * return undefined. Otherwise return the value as initially read from the DOM.\n     */\n    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName) {\n    if (this.events[eventName]) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      this.events[eventName].notify(...args);\n    }\n  }\n  scheduleRenderMicrotask() {\n    microtask.render(this.render);\n  }\n}\nexport { VisualElement, getFeatureDefinitions, setFeatureDefinitions };","map":{"version":3,"names":["propEventHandlers","featureDefinitions","setFeatureDefinitions","definitions","getFeatureDefinitions","VisualElement","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","constructor","_ref","parent","props","presenceContext","reducedMotionConfig","blockInitialAnimation","visualState","options","arguments","length","undefined","current","children","Set","isVariantNode","isControllingVariants","shouldReduceMotion","values","Map","KeyframeResolver","features","valueSubscriptions","prevMotionValues","events","propEventSubscriptions","notifyUpdate","notify","latestValues","render","triggerBuild","renderInstance","renderState","style","projection","renderScheduledAt","scheduleRender","now","time","frame","baseTarget","_objectSpread","initialValues","initial","depth","Boolean","variantChildren","manuallyAnimateOnMount","_this$scrapeMotionVal","willChange","initialMotionValues","_objectWithoutProperties","_excluded","key","value","isMotionValue","set","mount","instance","_this$parent","visualElementStore","removeFromVariantTree","addVariantChild","forEach","bindToMotionValue","hasReducedMotionListener","initPrefersReducedMotion","prefersReducedMotion","process","env","NODE_ENV","warnOnce","addChild","update","unmount","_this$parent2","cancelFrame","remove","clear","removeChild","feature","isMounted","child","_this$enteringChildre","add","enteringChildren","delete","has","get","valueIsTransform","transformProps","onBindTransform","removeOnChange","on","latestValue","onUpdate","preRender","isTransformDirty","removeSyncCheck","window","MotionCheckAppearSync","owner","stop","sortNodePosition","other","sortInstanceNodePosition","type","updateFeatures","featureDefinition","isEnabled","Feature","FeatureConstructor","build","measureViewportBox","measureInstanceViewportBox","createBox","getStaticValue","setStaticValue","transformTemplate","prevProps","prevPresenceContext","i","listenerName","listener","updateMotionValuesFromProps","handleChildMotionValue","getProps","getVariant","name","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getClosestVariantNode","closestVariantNode","addValue","existingValue","removeValue","unsubscribe","removeValueFromRenderState","hasValue","getValue","defaultValue","motionValue","readValue","target","_this$getBaseTargetFr","getBaseTargetFromProps","readValueFromInstance","isNumericalString","isZeroValueString","parseFloat","findValueType","complex","test","getAnimatableNone","setBaseTarget","getBaseTarget","valueFromInitial","_this$presenceContext","variant","resolveVariantFromProps","custom","eventName","callback","SubscriptionManager","_len","args","Array","_key","scheduleRenderMicrotask","microtask"],"sources":["C:\\Users\\Asus\\Desktop\\My projects\\PortFolio\\Frontend\\node_modules\\motion-dom\\src\\render\\VisualElement.ts"],"sourcesContent":["import { Box } from \"motion-utils\"\nimport {\n    isNumericalString,\n    isZeroValueString,\n    SubscriptionManager,\n    warnOnce,\n} from \"motion-utils\"\nimport { cancelFrame, frame } from \"../frameloop\"\nimport { microtask } from \"../frameloop/microtask\"\nimport { time } from \"../frameloop/sync-time\"\nimport { motionValue, MotionValue } from \"../value\"\nimport { isMotionValue } from \"../value/utils/is-motion-value\"\nimport { KeyframeResolver } from \"../animation/keyframes/KeyframesResolver\"\nimport type { AnyResolvedKeyframe } from \"../animation/types\"\nimport { transformProps } from \"./utils/keys-transform\"\nimport { complex } from \"../value/types/complex\"\nimport { findValueType } from \"../value/types/utils/find\"\nimport { getAnimatableNone } from \"../value/types/utils/animatable-none\"\nimport type { MotionNodeOptions } from \"../node/types\"\nimport { createBox } from \"../projection/geometry/models\"\nimport {\n    initPrefersReducedMotion,\n    hasReducedMotionListener,\n    prefersReducedMotion,\n} from \"./utils/reduced-motion\"\nimport { visualElementStore } from \"./store\"\nimport {\n    ResolvedValues,\n    VisualElementEventCallbacks,\n    VisualElementOptions,\n    PresenceContextProps,\n    ReducedMotionConfig,\n    FeatureDefinitions,\n    MotionConfigContextProps,\n} from \"./types\"\nimport { AnimationState } from \"./utils/animation-state\"\nimport {\n    isControllingVariants as checkIsControllingVariants,\n    isVariantNode as checkIsVariantNode,\n} from \"./utils/is-controlling-variants\"\nimport { updateMotionValuesFromProps } from \"./utils/motion-values\"\nimport { resolveVariantFromProps } from \"./utils/resolve-variants\"\nimport { Feature } from \"./Feature\"\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n] as const\n\n/**\n * Static feature definitions - can be injected by framework layer\n */\nlet featureDefinitions: Partial<FeatureDefinitions> = {}\n\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\nexport function setFeatureDefinitions(definitions: Partial<FeatureDefinitions>) {\n    featureDefinitions = definitions\n}\n\n/**\n * Get the current feature definitions\n */\nexport function getFeatureDefinitions(): Partial<FeatureDefinitions> {\n    return featureDefinitions\n}\n\n/**\n * Motion style type - a subset of CSS properties that can contain motion values\n */\nexport type MotionStyle = {\n    [K: string]: AnyResolvedKeyframe | MotionValue | undefined\n}\n\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nexport abstract class VisualElement<\n    Instance = unknown,\n    RenderState = unknown,\n    Options extends {} = {}\n> {\n    /**\n     * VisualElements are arranged in trees mirroring that of the React tree.\n     * Each type of VisualElement has a unique name, to detect when we're crossing\n     * type boundaries within that tree.\n     */\n    abstract type: string\n\n    /**\n     * An `Array.sort` compatible function that will compare two Instances and\n     * compare their respective positions within the tree.\n     */\n    abstract sortInstanceNodePosition(a: Instance, b: Instance): number\n\n    /**\n     * Measure the viewport-relative bounding box of the Instance.\n     */\n    abstract measureInstanceViewportBox(\n        instance: Instance,\n        props: MotionNodeOptions & Partial<MotionConfigContextProps>\n    ): Box\n\n    /**\n     * When a value has been removed from all animation props we need to\n     * pick a target to animate back to. For instance, for HTMLElements\n     * we can look in the style prop.\n     */\n    abstract getBaseTargetFromProps(\n        props: MotionNodeOptions,\n        key: string\n    ): AnyResolvedKeyframe | undefined | MotionValue\n\n    /**\n     * When we first animate to a value we need to animate it *from* a value.\n     * Often this have been specified via the initial prop but it might be\n     * that the value needs to be read from the Instance.\n     */\n    abstract readValueFromInstance(\n        instance: Instance,\n        key: string,\n        options: Options\n    ): AnyResolvedKeyframe | null | undefined\n\n    /**\n     * When a value has been removed from the VisualElement we use this to remove\n     * it from the inherting class' unique render state.\n     */\n    abstract removeValueFromRenderState(\n        key: string,\n        renderState: RenderState\n    ): void\n\n    /**\n     * Run before a React or VisualElement render, builds the latest motion\n     * values into an Instance-specific format. For example, HTMLVisualElement\n     * will use this step to build `style` and `var` values.\n     */\n    abstract build(\n        renderState: RenderState,\n        latestValues: ResolvedValues,\n        props: MotionNodeOptions\n    ): void\n\n    /**\n     * Apply the built values to the Instance. For example, HTMLElements will have\n     * styles applied via `setProperty` and the style attribute, whereas SVGElements\n     * will have values applied to attributes.\n     */\n    abstract renderInstance(\n        instance: Instance,\n        renderState: RenderState,\n        styleProp?: MotionStyle,\n        projection?: any\n    ): void\n\n    /**\n     * This method is called when a transform property is bound to a motion value.\n     * It's currently used to measure SVG elements when a new transform property is bound.\n     */\n    onBindTransform?(): void\n\n    /**\n     * If the component child is provided as a motion value, handle subscriptions\n     * with the renderer-specific VisualElement.\n     */\n    handleChildMotionValue?(): void\n\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(\n        _props: MotionNodeOptions,\n        _prevProps: MotionNodeOptions,\n        _visualElement: VisualElement\n    ): {\n        [key: string]: MotionValue | AnyResolvedKeyframe\n    } {\n        return {}\n    }\n\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    current: Instance | null = null\n\n    /**\n     * A reference to the parent VisualElement (if exists).\n     */\n    parent: VisualElement | undefined\n\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    children = new Set<VisualElement>()\n\n    /**\n     * A set containing the latest children of this VisualElement. This is flushed\n     * at the start of every commit. We use it to calculate the stagger delay\n     * for newly-added children.\n     */\n    enteringChildren?: Set<VisualElement>\n\n    /**\n     * The depth of this VisualElement within the overall VisualElement tree.\n     */\n    depth: number\n\n    /**\n     * The current render state of this VisualElement. Defined by inherting VisualElements.\n     */\n    renderState: RenderState\n\n    /**\n     * An object containing the latest static values for each of this VisualElement's\n     * MotionValues.\n     */\n    latestValues: ResolvedValues\n\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    isVariantNode: boolean = false\n    isControllingVariants: boolean = false\n\n    /**\n     * If this component is part of the variant tree, it should track\n     * any children that are also part of the tree. This is essentially\n     * a shadow tree to simplify logic around how to stagger over children.\n     */\n    variantChildren?: Set<VisualElement>\n\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    shouldReduceMotion: boolean | null = null\n\n    /**\n     * Normally, if a component is controlled by a parent's variants, it can\n     * rely on that ancestor to trigger animations further down the tree.\n     * However, if a component is created after its parent is mounted, the parent\n     * won't trigger that mount animation so the child needs to.\n     *\n     * TODO: This might be better replaced with a method isParentMounted\n     */\n    manuallyAnimateOnMount: boolean\n\n    /**\n     * This can be set by AnimatePresence to force components that mount\n     * at the same time as it to mount as if they have initial={false} set.\n     */\n    blockInitialAnimation: boolean\n\n    /**\n     * A reference to this VisualElement's projection node, used in layout animations.\n     */\n    projection?: any\n\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    values = new Map<string, MotionValue>()\n\n    /**\n     * The AnimationState, this is hydrated by the animation Feature.\n     */\n    animationState?: AnimationState\n\n    KeyframeResolver = KeyframeResolver\n\n    /**\n     * The options used to create this VisualElement. The Options type is defined\n     * by the inheriting VisualElement and is passed straight through to the render functions.\n     */\n    readonly options: Options\n\n    /**\n     * A reference to the latest props provided to the VisualElement's host React component.\n     */\n    props: MotionNodeOptions\n    prevProps?: MotionNodeOptions\n\n    presenceContext: PresenceContextProps | null\n    prevPresenceContext?: PresenceContextProps | null\n\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    private features: {\n        [K in keyof FeatureDefinitions]?: Feature<Instance>\n    } = {}\n\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    private valueSubscriptions = new Map<string, VoidFunction>()\n\n    /**\n     * A reference to the ReducedMotionConfig passed to the VisualElement's host React component.\n     */\n    private reducedMotionConfig: ReducedMotionConfig | undefined\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n    private removeFromVariantTree: undefined | VoidFunction\n\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    private prevMotionValues: MotionStyle = {}\n\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n    private baseTarget: ResolvedValues\n\n    /**\n     * Create an object of the values we initially animated from (if initial prop present).\n     */\n    private initialValues: ResolvedValues\n\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events: {\n        [key: string]: SubscriptionManager<any>\n    } = {}\n\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    private propEventSubscriptions: {\n        [key: string]: VoidFunction\n    } = {}\n\n    constructor(\n        {\n            parent,\n            props,\n            presenceContext,\n            reducedMotionConfig,\n            blockInitialAnimation,\n            visualState,\n        }: VisualElementOptions<Instance, RenderState>,\n        options: Options = {} as any\n    ) {\n        const { latestValues, renderState } = visualState\n        this.latestValues = latestValues\n        this.baseTarget = { ...latestValues }\n        this.initialValues = props.initial ? { ...latestValues } : {}\n        this.renderState = renderState\n        this.parent = parent\n        this.props = props\n        this.presenceContext = presenceContext\n        this.depth = parent ? parent.depth + 1 : 0\n        this.reducedMotionConfig = reducedMotionConfig\n        this.options = options\n        this.blockInitialAnimation = Boolean(blockInitialAnimation)\n\n        this.isControllingVariants = checkIsControllingVariants(props)\n        this.isVariantNode = checkIsVariantNode(props)\n        if (this.isVariantNode) {\n            this.variantChildren = new Set()\n        }\n\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current)\n\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } =\n            this.scrapeMotionValuesFromProps(props, {}, this)\n\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key]\n\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key])\n            }\n        }\n    }\n\n    mount(instance: Instance) {\n        this.current = instance\n\n        visualElementStore.set(instance, this)\n\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance)\n        }\n\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this)\n        }\n\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value))\n\n        /**\n         * Determine reduced motion preference. Only initialize the matchMedia\n         * listener if we actually need the dynamic value (i.e., when config\n         * is neither \"never\" nor \"always\").\n         */\n        if (this.reducedMotionConfig === \"never\") {\n            this.shouldReduceMotion = false\n        } else if (this.reducedMotionConfig === \"always\") {\n            this.shouldReduceMotion = true\n        } else {\n            if (!hasReducedMotionListener.current) {\n                initPrefersReducedMotion()\n            }\n            this.shouldReduceMotion = prefersReducedMotion.current\n        }\n\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(\n                this.shouldReduceMotion !== true,\n                \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\",\n                \"reduced-motion-disabled\"\n            )\n        }\n\n        this.parent?.addChild(this)\n\n        this.update(this.props, this.presenceContext)\n    }\n\n    unmount() {\n        this.projection && this.projection.unmount()\n        cancelFrame(this.notifyUpdate)\n        cancelFrame(this.render)\n        this.valueSubscriptions.forEach((remove) => remove())\n        this.valueSubscriptions.clear()\n        this.removeFromVariantTree && this.removeFromVariantTree()\n        this.parent?.removeChild(this)\n\n        for (const key in this.events) {\n            this.events[key].clear()\n        }\n\n        for (const key in this.features) {\n            const feature = this.features[key as keyof typeof this.features]\n            if (feature) {\n                feature.unmount()\n                feature.isMounted = false\n            }\n        }\n        this.current = null\n    }\n\n    addChild(child: VisualElement) {\n        this.children.add(child)\n        this.enteringChildren ??= new Set()\n        this.enteringChildren.add(child)\n    }\n\n    removeChild(child: VisualElement) {\n        this.children.delete(child)\n        this.enteringChildren && this.enteringChildren.delete(child)\n    }\n\n    private bindToMotionValue(key: string, value: MotionValue) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)!()\n        }\n\n        const valueIsTransform = transformProps.has(key)\n\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform()\n        }\n\n        const removeOnChange = value.on(\n            \"change\",\n            (latestValue: AnyResolvedKeyframe) => {\n                this.latestValues[key] = latestValue\n\n                this.props.onUpdate && frame.preRender(this.notifyUpdate)\n\n                if (valueIsTransform && this.projection) {\n                    this.projection.isTransformDirty = true\n                }\n\n                this.scheduleRender()\n            }\n        )\n\n        let removeSyncCheck: VoidFunction | void\n        if (typeof window !== \"undefined\" && (window as any).MotionCheckAppearSync) {\n            removeSyncCheck = (window as any).MotionCheckAppearSync(this, key, value)\n        }\n\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange()\n            if (removeSyncCheck) removeSyncCheck()\n            if (value.owner) value.stop()\n        })\n    }\n\n    sortNodePosition(other: VisualElement<Instance>) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (\n            !this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type\n        ) {\n            return 0\n        }\n\n        return this.sortInstanceNodePosition(\n            this.current as Instance,\n            other.current as Instance\n        )\n    }\n\n    updateFeatures() {\n        let key: keyof typeof featureDefinitions = \"animation\"\n\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key]\n\n            if (!featureDefinition) continue\n\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition\n\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (\n                !this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)\n            ) {\n                this.features[key] = new FeatureConstructor(this) as any\n            }\n\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key]!\n                if (feature.isMounted) {\n                    feature.update()\n                } else {\n                    feature.mount()\n                    feature.isMounted = true\n                }\n            }\n        }\n    }\n\n    notifyUpdate = () => this.notify(\"Update\", this.latestValues)\n\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props)\n    }\n\n    render = () => {\n        if (!this.current) return\n        this.triggerBuild()\n        this.renderInstance(\n            this.current,\n            this.renderState,\n            (this.props as any).style,\n            this.projection\n        )\n    }\n\n    private renderScheduledAt = 0.0\n    scheduleRender = () => {\n        const now = time.now()\n        if (this.renderScheduledAt < now) {\n            this.renderScheduledAt = now\n            frame.render(this.render, false, true)\n        }\n    }\n\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox()\n    }\n\n    getStaticValue(key: string) {\n        return this.latestValues[key]\n    }\n\n    setStaticValue(key: string, value: AnyResolvedKeyframe) {\n        this.latestValues[key] = value\n    }\n\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props: MotionNodeOptions, presenceContext: PresenceContextProps | null) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender()\n        }\n\n        this.prevProps = this.props\n        this.props = props\n\n        this.prevPresenceContext = this.presenceContext\n        this.presenceContext = presenceContext\n\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i]\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]()\n                delete this.propEventSubscriptions[key]\n            }\n\n            const listenerName = (\"on\" + key) as keyof typeof props\n            const listener = props[listenerName]\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key as any, listener)\n            }\n        }\n\n        this.prevMotionValues = updateMotionValuesFromProps(\n            this,\n            this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this),\n            this.prevMotionValues\n        )\n\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue()\n        }\n    }\n\n    getProps() {\n        return this.props\n    }\n\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name: string) {\n        return this.props.variants ? this.props.variants[name] : undefined\n    }\n\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition\n    }\n\n    getTransformPagePoint() {\n        return (this.props as any).transformPagePoint\n    }\n\n    getClosestVariantNode(): VisualElement | undefined {\n        return this.isVariantNode\n            ? this\n            : this.parent\n            ? this.parent.getClosestVariantNode()\n            : undefined\n    }\n\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child: VisualElement) {\n        const closestVariantNode = this.getClosestVariantNode()\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child)\n            return () => closestVariantNode.variantChildren!.delete(child)\n        }\n    }\n\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key: string, value: MotionValue) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key)\n\n        if (value !== existingValue) {\n            if (existingValue) this.removeValue(key)\n            this.bindToMotionValue(key, value)\n            this.values.set(key, value)\n            this.latestValues[key] = value.get()\n        }\n    }\n\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key: string) {\n        this.values.delete(key)\n        const unsubscribe = this.valueSubscriptions.get(key)\n        if (unsubscribe) {\n            unsubscribe()\n            this.valueSubscriptions.delete(key)\n        }\n        delete this.latestValues[key]\n        this.removeValueFromRenderState(key, this.renderState)\n    }\n\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key: string) {\n        return this.values.has(key)\n    }\n\n    /**\n     * Get a motion value for this key. If called with a default\n     * value, we'll create one if none exists.\n     */\n    getValue(key: string): MotionValue | undefined\n    getValue(key: string, defaultValue: AnyResolvedKeyframe | null): MotionValue\n    getValue(\n        key: string,\n        defaultValue?: AnyResolvedKeyframe | null\n    ): MotionValue | undefined {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key]\n        }\n\n        let value = this.values.get(key)\n\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(\n                defaultValue === null ? undefined : defaultValue,\n                { owner: this }\n            )\n            this.addValue(key, value)\n        }\n\n        return value\n    }\n\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key: string, target?: AnyResolvedKeyframe | null) {\n        let value =\n            this.latestValues[key] !== undefined || !this.current\n                ? this.latestValues[key]\n                : this.getBaseTargetFromProps(this.props, key) ??\n                  this.readValueFromInstance(this.current, key, this.options)\n\n        if (value !== undefined && value !== null) {\n            if (\n                typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))\n            ) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value)\n            } else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target as string)\n            }\n\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)\n        }\n\n        return isMotionValue(value) ? value.get() : value\n    }\n\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key: string, value: AnyResolvedKeyframe) {\n        this.baseTarget[key] = value\n    }\n\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key: string): ResolvedValues[string] | undefined | null {\n        const { initial } = this.props\n\n        let valueFromInitial: ResolvedValues[string] | undefined | null\n\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(\n                this.props,\n                initial as any,\n                this.presenceContext?.custom\n            )\n            if (variant) {\n                valueFromInitial = variant[\n                    key as keyof typeof variant\n                ] as string\n            }\n        }\n\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial\n        }\n\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key)\n        if (target !== undefined && !isMotionValue(target)) return target\n\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key]\n    }\n\n    on<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        callback: VisualElementEventCallbacks[EventName]\n    ) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager()\n        }\n\n        return this.events[eventName].add(callback)\n    }\n\n    notify<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        ...args: any\n    ) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args)\n        }\n    }\n\n    scheduleRenderMicrotask() {\n        microtask.render(this.render)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}